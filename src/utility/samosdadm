#!/bin/ksh

#    SAM-QFS_notice_begin
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at pkg/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at pkg/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
#    SAM-QFS_notice_end

#
# samosdadm - see help entry below for details.
#
#	$Revision: 1.1 $
#

#
# Initial stuff.
#
CFGFILE=/etc/opt/SUNWsamfs/osd
CMDNAME=$0
SAVELINE=""
ENTRYNO=0
LINENO=0

#
# Admin. programs we need
#
ITADM=/usr/sbin/itadm
HOST=/usr/sbin/host
MODINFO=/usr/sbin/modinfo
PKGINFO=/bin/pkginfo
SVCADM=/usr/sbin/svcadm
SVCS=/bin/svcs
OSDTADM=/usr/sbin/osdtadm
ISCSIADM=/usr/sbin/iscsiadm
STMFADM=/bin/stmfadm
SAMOSDADM=/opt/SUNWsamfs/sbin/samosdadm
DEVFSADM=/usr/sbin/devfsadm


#
# Echo error message with prepended command name and subcommand.
#
echoe()
{
	if [ -z "$SUBCMD" ]
	then
		echo `basename $CMDNAME`: $*
	else
		echo `basename $CMDNAME`: "$SUBCMD:" $*
	fi
}


#
# Echo error message with prepended command name and subcommand to stderr.
#
echoee()
{
	echoe $* 1>&2
}


#
# Read config file line.
#
read_line()
{
	typeset L
	ERR=""
	if [ -z "$SAVELINE" ]
	then
		!  L=`line` && return 1
	else
		echo $SAVELINE
		return 0
	fi
	typeset LL=`echo $L | awk '
		{
			if((NF == 3) && ($2 == "="))
				print $1 " = " $3
		}'`
	if [ -z "$LL" ]
	then
		ERR="Syntax error"
		echoee "$ERR in config file line $LINENO at: $L"
		return -1
	fi
	echo $LL
	LINENO=`expr $LINENO + 1`
	return 0
}


#
# Read config file entry.  Each "guid = xxx" starts a new entry.
#
read_OSD_ent()
{
	GUID=""
	IQN=""
	DEVICE=""
	PEER_IP=""
	PEER_IP_PORT=""
	FS_NAME=""

	typeset L
	while L=`read_line`
	do
		set -- `echo $L`
		KEYWORD=$1
		VALUE=$3
		case $KEYWORD in
			guid)
				if [ -z "$GUID" ]
				then
					GUID=$VALUE
					SAVELINE=""
				else
					SAVELINE=$L
					break
				fi
				;;
			iqn)
				IQN=$VALUE
				;;
			device)
				DEVICE=$VALUE
				;;
			peer_ip)
				PEER_IP=$VALUE
				;;
			peer_ip_port)
				PEER_IP_PORT=$VALUE
				;;
			fs_name)
				FS_NAME=$VALUE
				;;
		esac
	done
	ENTRYNO=`expr $ENTRYNO + 1`
	if [ -z "$SAVELINE" -a -z "$GUID" ]
	then
		return 1
	else
		return 0
	fi
}


#
# Write osd config file entry.
#
write_OSD_ent()
{
	echo "guid = " $GUID
	echo "	iqn = " $IQN
	echo "	device = " $DEVICE
	echo "	peer_ip = " $PEER_IP
	echo "	peer_ip_port = " $PEER_IP_PORT
	echo "	fs_name = " $FS_NAME
}


#
# Convert an ip address to name.
#
host_name()
{
	typeset H
	H=`$HOST $1 | head -1 | awk '
		($4 == "pointer") {print substr($5, 1, length($5)-1)}' `
	if [ -z "$H" ]
	then
		H=`grep $1 /etc/hosts | head -1  | awk '{print $2}'`
	fi
	echo $H
}


#
# Check for proper OS and level.
#
check_os()
{
	typeset OS=`uname -s`
	typeset REL=`uname -r | awk -F. '{print $2}'`
	if [ "$OS" != "$1" -o "$REL" -lt "$2" ]
	then
		echoee "OS must be Solaris 5.11 or greater"
		exit 1
	fi
}


#
# Check to see that SAM-QFS is installed.
#
check_samqfs()
{
	if ! $PKGINFO -q SUNWsamfsr SUNWsamfsu
	then
		if ! $PKGINFO SUNWqfsr SUNWqfsu
		then
			echoee "SAM-QFS package not installed."
			exit 1
		fi
	fi
}


#
# Check to see that a set of packages are installed.
#
check_pkg()
{
	if ! $PKGINFO -q $*
	then
		echoee "$* package(s) not installed."
		exit 1
	fi
}


#
# Check to see that a module is installed.
#
check_mod()
{
	if ! $MODINFO | grep $1 >/dev/null
	then
		echoee "$1 module not installed."
		exit 1
	fi
}


#
# Check to see that a set of binaries are installed.
#
check_bin()
{
	for B in $*
	do
		if [ ! -x $B ]
		then
			echoee "$B admin command not installed."
			exit 1
		fi
	done
}


#
#
# Check scsi_vhci driver to rule out certain versions.
#
check_scsi_vhci()
{
	typeset REL=`$MODINFO | grep " scsi_vhci " | awk '{print $10}'`
	if [ "$REL" -eq "1.67)" ]
	then
		echoee "Bad version ($REL of scsi_vhci installed."
		exit 1
	fi
}


#
# Touch config file.  Create it if it doesn't exist with proper options.
#
touch_config_file()
{
	typeset F=$1
	if [ ! -f $F ]
	then
		if ! touch $F
		then
			echoee "Unable to create $F."
			exit 1
		fi
		chmod 640 $F
	fi
	if [ -r $F -a -w $F ]
	then
		return 0
	fi
	echoee "$F not read/writable."
	exit 1
}


#
# check_root - check that we are being run as root
#
check_root()
{
	ROOT=`/bin/id | awk '($1 == "uid=0(root)") { print }'`
	if [ -z "$ROOT" ]
	then
		echoee "must be run as root."
		exit 1
	fi
}


#
# Check for required option.
#
req_opt()
{
	typeset OPTNAME=$1
	typeset OPTFLAG=$2
	if [ "$OPTFLAG" != "y" ]
	then
		echoee "requires -${OPTNAME} option."
		exit 2
	fi
}



#
# ===== Start of samosdadm main script =====
#
# Pre-process subcommand.
#
SUBCMD=$1
ARGS=""
case $SUBCMD in
	""|help)
		echo `basename $CMDNAME` "subcommand [arguments]"
		echo "	Available subcommands:"
		echo "	help - show help (this output)."
		echo "Subcommands for SAM-QFS servers and clients:"
		echo "	list [-v] [-n] list all SAM-QFS object OSD targets."
		echo "		-v = verbose"
		echo "		-n = entry #"
		echo "	checkclient_sw - check for proper software levels" \
		    "on client."
		echo "	addosd -g guid -i iqn -o osd_ip [-p port] -f fs_name"
		echo "		create osd entry on initiator"
		echo "	deleteosd -n"
		echo "		delete osd entry on initiator"
		echo "Subcommands for SAM-QFS OSD targets:"
		echo "	checkosd_sw - check for proper software levels on OSD."
		echo "	createosd -f fs - create osd on target."
		echo "	destroyosd -f fs - create osd on target."
		exit 0
		;;
	list)
		ARGS="n:v"
		;;
	checkclient_sw|checkosd_sw)
		;;
	createosd|destroyosd)
		ARGS="f:"
		;;
	addosd)
		ARGS="g:i:o:p:f:"
		;;
	deleteosd)
		ARGS="n:"
		;;
	*)
		echo "$CMDNAME: Illegal subcommand \"$SUBCMD\"." 1>&2
		exit 2
		;;
esac

#
# Process arguments.
#
shift
if [ -n "$ARGS" ]
then
	while getopts $ARGS ARG
	do
		case "${ARG}" in
			f) FOPT=y ; FOPT_ARG=$OPTARG ;;
			g) GOPT=y ; GOPT_ARG=$OPTARG ;;
			i) IOPT=y ; IOPT_ARG=$OPTARG ;;
			n) NOPT=y ; NOPT_ARG=$OPTARG ;;
			o) OOPT=y ; OOPT_ARG=$OPTARG ;;
			p) POPT=y ; POPT_ARG=$OPTARG ;;
			v) VOPT=y ;;
			*) echoee "Illegal argument $ARG"
				exit 2 ;;
		esac
	done
fi

#
# Process and check for required options.
#
case $SUBCMD in
	createosd|destroyosd)
		req_opt f "$FOPT"
		;;
	addosd)
		req_opt f "$FOPT"
		req_opt g "$GOPT"
		req_opt i "$IOPT"
		req_opt o "$OOPT"
		;;
	deleteosd)
		req_opt n "$NOPT"
		;;
esac

#
# Done with argument checking and so forth.  Check for root and then
# do actual subcommand.
#
check_root
case $SUBCMD in
	#
	# List OSD entries.
	#
	list)
		echo "Entry\tFilesystem\tOSD\t\tGUID"
		echo "-----\t----------\t---\t\t----"
		touch_config_file $CFGFILE
		test ! -r $CFGFILE && exit 0
		while read_OSD_ent
		do
			if [ -n "$NOPT" -a $ENTRYNO -ne "$NOPT_ARG" ]
			then
				continue
			fi
			echo $ENTRYNO $FS_NAME $PEER_IP $GUID | awk '{
				printf("%-7d %-15s %s\t%s\n", $1, $2, $3, $4);
			}'
			if [ -n "$VOPT" ]
			then
				H=`host_name $PEER_IP`
				echo "\tiqn =" $IQN
				echo "\tdevice =" $DEVICE
				echo "\tpeer_ip =" $PEER_IP "(" $H ")"
				echo "\tpeer_ip_port =" $PEER_IP_PORT
			fi
		done <$CFGFILE
		;;

	#
	# Check for proper software on initiator client (MDS or shared client).
	#
	checkclient_sw)
		check_os SunOS 11
		check_samqfs
		check_pkg SUNWsosdr SUNWsosdu
		check_scsi_vhci
		check_bin $ISCSIADM
		;;

	#
	# Check for proper software on OSD target.
	#
	checkosd_sw)
		check_os SunOS 11
		check_samqfs
		check_pkg SUNWstmf
		STMFSTATE=`$SVCS -Ho STATE stmf`
		if [ $? -ne 0 ]
		then
			echoee "stmf in unknown state"
			exit 1
		fi
		$SVCADM enable stmf
		check_pkg SUNWiscsitr
		check_mod osdt
		check_bin $ITADM $OSDTADM $STMFADM $ISCSIADM
		;;

	#
	# Create OSD.  This is inteded to be run on the OSD.
	#
	createosd)
		#
		# Check for proper software installed.
		#
		$SAMOSDADM checkosd_sw

		#
		# Mount backing store for target.
		#
		if ! mount $FOPT_ARG
		then
			echoee "mount $FOPT_ARG failed."
			exit 1
		fi
		echoe "backing store $FOPT_ARG mounted." 
		#
		# Create target IQN.  Use existing one if already created.
		#
		TIQN=`$ITADM list-target  | awk '($1 == "Target:") {print $2}'`
		if [ -z "$TIQN" ]
		then
			if ! $ITADM create-target
			then
				echoee "$ITADM create-target failed."
				exit 1
			fi
			TIQN=`$ITADM list-target  | \
			    awk '($1 == "Target:") {print $2}'`
			echoe "created IQN:"
		else
			echoe "using IQN:"
		fi
		echo "\t$TIQN"

		#
		# Create LUN for target.
		#
		G=`$OSDTADM lu-create -f $FOPT_ARG`
		if [ $? -ne 0 ]
		then
			echoee "osdtadm LUN create failed."
			exit 1
		fi
		GUID=`echo $G | awk '{print $3}'`
		echoe "LUN created, GUID:"
		echo "\t$GUID"

		#
		# Online the LUN.
		#
		if ! $OSDTADM lu-online -f $FOPT_ARG
		then
			echoee "osdtadm lu-online failed."
			exit 1
		fi
		echoe "LUN online."

		#
		# Add LUN to stmf.
		#
		if ! $STMFADM add-view --lun 0 $GUID
		then
			echoee "stmfadm add-view failed."
			exit 1
		fi
		echoe "LUN added to stmf."
		echoe "complete."
		;;

	#
	# Destroy OSD.  This is inteded to be run on the OSD.
	#
	destroyosd)
		#
		# Offline the LUN.
		#
		if ! $OSDTADM lu-offline -f $FOPT_ARG
		then
			echoee "osdtadm lu-offline failed."
			exit 1
		fi
		echoe "LUN offline."

		#
		# Delete LUN for target. XXX to be done yet.
		# osdtadm lu-delete does not exist yet!
		#

		#
		# Unmount the backing store.
		#
		if ! umount $FOPT_ARG
		then
			echoee "umount $FOPT_ARG failed."
			exit 1
		fi
		echoe "backing store $FOPT_ARG unmounted."

		#
		# Delete LUN from stmf.
		#
		if ! $STMFADM remove-view -a
		then
			echoee "stmfadm remove-view failed."
			exit 1
		fi
		echoe "LUN deleted from stmf."

		#
		# Delete target IQN.
		#
		TIQN=`$ITADM list-target  | awk '($1 == "Target:") {print $2}'`
		if ! $ITADM delete-target $TIQN
		then
			echoee "itadm delete-target failed."
			exit 1
		fi
		echoe "deleted IQN:"
		echo "\t$TIQN"
		echoe "complete."
		;;

	#
	# Create OSD.  This is inteded to be run on an initiator.
	#
	addosd)
		touch_config_file $CFGFILE

		#
		# Default port to 3260 if not specified.
		#
		test -z "$POPT" && POPT_ARG=3260

		#
		# Check for proper software installed.
		#
		$SAMOSDADM checkclient_sw

		#
		# Set entries for write_OSD_ent.
		#
		GUID=$GOPT_ARG
		IQN=$IOPT_ARG
		DEVICE="/dev/osd/osd${GOPT_ARG},root"
		PEER_IP=$OOPT_ARG
		PEER_IP_PORT=$POPT_ARG
		FS_NAME=$FOPT_ARG

		#
		# Add config to iscsi.
		#
		if ! $ISCSIADM add static-config $IQN,$PEER_IP:$PEER_IP_PORT
		then
			echoee "iscsiadm add static-config failed."
			exit 1
		fi
		sleep 1

		#
		# Cause sosd to probe for new entries
		#
		$DEVFSADM -c disk

		#
		# Set up iscsimodes.
		#
		$ISCSIADM modify discovery -t disable
		$ISCSIADM modify discovery -s enable

		#
		# Write out config file entry.
		#
		write_OSD_ent >>$CFGFILE
		echoe "guid $GUID added successsfully."
		;;

	#
	# Delete OSD.  This is inteded to be run on an initiator.
	#
	deleteosd)
		rm -f $CFGFILE.new
		touch_config_file $CFGFILE.new

		#
		# Scan current config looking for requested entry number.
		#
		while read_OSD_ent
		do
			if [ $ENTRYNO -eq "$NOPT_ARG" ]
			then
				#
				# Entry was found, do deletion.
				#
				FOUND=$ENTRYNO
				FOUNDG=$GUID
				if ! $ISCSIADM remove static-config \
				    $IQN,$PEER_IP:$PEER_IP_PORT
				then
					echoee "iscsiadm add static-config" \
					    "failed."
					exit 1
				fi
			else
				write_OSD_ent >>$CFGFILE.new
			fi
		done <$CFGFILE

		#
		# If not found, error.
		#
		if [ -z "$FOUND" ]
		then
			rm -f $CFGFILE.new
			echoee "entry number $NOPT_ARG out of range"
			exit 1
		fi

		#
		# Update config file and quit.
		#
		mv $CFGFILE.new $CFGFILE
		echoe "entry $FOUND, guid $FOUNDG deleted successsfully."
		;;
esac
